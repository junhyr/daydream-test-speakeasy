/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Base U-Net model to use for generation. Default: "stabilityai/sd-turbo"
 */
export const UpdateStreamModelId = {
  StabilityaiSdTurbo: "stabilityai/sd-turbo",
  PromptheroOpenjourneyV4: "prompthero/openjourney-v4",
  LykonDreamshaper8: "Lykon/dreamshaper-8",
  StabilityaiSdxlTurbo: "stabilityai/sdxl-turbo",
} as const;
/**
 * Base U-Net model to use for generation. Default: "stabilityai/sd-turbo"
 */
export type UpdateStreamModelId = ClosedEnum<typeof UpdateStreamModelId>;

export type UpdateStreamPrompt2 = string | number;

/**
 * Text prompt describing the desired image. Can be a single string or weighted list of (prompt, weight) tuples.
 */
export type UpdateStreamPrompt1 = string | Array<Array<string | number>>;

/**
 * Method for interpolating between multiple prompts. Slerp provides smoother transitions than linear.
 */
export const UpdateStreamPromptInterpolationMethod = {
  Linear: "linear",
  Slerp: "slerp",
} as const;
/**
 * Method for interpolating between multiple prompts. Slerp provides smoother transitions than linear.
 */
export type UpdateStreamPromptInterpolationMethod = ClosedEnum<
  typeof UpdateStreamPromptInterpolationMethod
>;

/**
 * Dictionary mapping LoRA model paths to their weights for fine-tuning the base model.
 */
export type UpdateStreamLoraDict = {};

export type UpdateStreamSeed2 = number | number;

/**
 * Random seed for generation. Can be a single integer or weighted list of (seed, weight) tuples.
 */
export type UpdateStreamSeed1 = number | Array<Array<number | number>>;

/**
 * Method for interpolating between multiple seeds. Slerp provides smoother transitions than linear.
 */
export const UpdateStreamSeedInterpolationMethod = {
  Linear: "linear",
  Slerp: "slerp",
} as const;
/**
 * Method for interpolating between multiple seeds. Slerp provides smoother transitions than linear.
 */
export type UpdateStreamSeedInterpolationMethod = ClosedEnum<
  typeof UpdateStreamSeedInterpolationMethod
>;

/**
 * ⚠️ NOTE: ControlNet model_ids must be unique. Additionally, they must be compatible with the selected base model.
 */
export const UpdateStreamControlnetModelId = {
  ThibaudControlnetSd21OpenposeDiffusers:
    "thibaud/controlnet-sd21-openpose-diffusers",
  ThibaudControlnetSd21HedDiffusers: "thibaud/controlnet-sd21-hed-diffusers",
  ThibaudControlnetSd21CannyDiffusers:
    "thibaud/controlnet-sd21-canny-diffusers",
  ThibaudControlnetSd21DepthDiffusers:
    "thibaud/controlnet-sd21-depth-diffusers",
  ThibaudControlnetSd21ColorDiffusers:
    "thibaud/controlnet-sd21-color-diffusers",
  LllyasvielControlV11f1pSd15Depth: "lllyasviel/control_v11f1p_sd15_depth",
  LllyasvielControlV11f1eSd15Tile: "lllyasviel/control_v11f1e_sd15_tile",
  LllyasvielControlV11pSd15Canny: "lllyasviel/control_v11p_sd15_canny",
  XinsirControlnetDepthSdxl10: "xinsir/controlnet-depth-sdxl-1.0",
  XinsirControlnetCannySdxl10: "xinsir/controlnet-canny-sdxl-1.0",
  XinsirControlnetTileSdxl10: "xinsir/controlnet-tile-sdxl-1.0",
} as const;
/**
 * ⚠️ NOTE: ControlNet model_ids must be unique. Additionally, they must be compatible with the selected base model.
 */
export type UpdateStreamControlnetModelId = ClosedEnum<
  typeof UpdateStreamControlnetModelId
>;

export type UpdateStreamControlnet = {
  /**
   * ⚠️ NOTE: ControlNet model_ids must be unique. Additionally, they must be compatible with the selected base model.
   */
  modelId: UpdateStreamControlnetModelId;
  /**
   * Strength of the ControlNet's influence on generation. Higher values make the model follow the control signal more strictly. Typical range 0.0-1.0, where 0.0 disables the control and 1.0 applies full control. Default: 1.0
   */
  conditioningScale: number;
  /**
   * Preprocessor to apply to input frames before feeding to the ControlNet. Common options include 'pose_tensorrt', 'soft_edge', 'canny', 'depth_tensorrt', 'passthrough'. If None, no preprocessing is applied.
   *
   * @remarks
   *
   * ⚠️ NOTE: ControlNet preprocessor must be in the available list (AVAILABLE_PREPROCESSORS).
   */
  preprocessor: string;
  /**
   * Additional parameters for the preprocessor. For example, canny edge detection uses 'low_threshold' and 'high_threshold' values.
   */
  preprocessorParams?: { [k: string]: any } | undefined;
  /**
   * Whether this ControlNet is active. Disabled ControlNets are not loaded. Default: true
   */
  enabled: boolean;
  /**
   * Fraction of the denoising process (0.0-1.0) when ControlNet guidance begins. 0.0 means guidance starts from the beginning.
   */
  controlGuidanceStart?: number | undefined;
  /**
   * Fraction of the denoising process (0.0-1.0) when ControlNet guidance ends. 1.0 means guidance continues until the end.
   */
  controlGuidanceEnd?: number | undefined;
};

/**
 * Type of IP adapter. Use 'faceid' for SDXL-faceid models, 'regular' for others
 */
export const UpdateStreamType = {
  Regular: "regular",
  Faceid: "faceid",
} as const;
/**
 * Type of IP adapter. Use 'faceid' for SDXL-faceid models, 'regular' for others
 */
export type UpdateStreamType = ClosedEnum<typeof UpdateStreamType>;

/**
 * Weight interpolation method for IP adapter style conditioning. Controls how the style influence changes throughout the generation process.
 */
export const UpdateStreamWeightType = {
  Linear: "linear",
  EaseIn: "ease in",
  EaseOut: "ease out",
  EaseInOut: "ease in-out",
  ReverseInOut: "reverse in-out",
  WeakInput: "weak input",
  WeakOutput: "weak output",
  WeakMiddle: "weak middle",
  StrongMiddle: "strong middle",
  StyleTransfer: "style transfer",
  Composition: "composition",
  StrongStyleTransfer: "strong style transfer",
  StyleAndComposition: "style and composition",
  StyleTransferPrecise: "style transfer precise",
  CompositionPrecise: "composition precise",
} as const;
/**
 * Weight interpolation method for IP adapter style conditioning. Controls how the style influence changes throughout the generation process.
 */
export type UpdateStreamWeightType = ClosedEnum<typeof UpdateStreamWeightType>;

/**
 * IP adapter — Turns on IP-Adapter style conditioning and is fully hot-swappable. Available for SDXL, SDXL-faceid, SD1.5
 */
export type UpdateStreamIpAdapter = {
  scale: number;
  enabled: boolean;
  /**
   * Type of IP adapter. Use 'faceid' for SDXL-faceid models, 'regular' for others
   */
  type?: UpdateStreamType | undefined;
  /**
   * Weight interpolation method for IP adapter style conditioning. Controls how the style influence changes throughout the generation process.
   */
  weightType?: UpdateStreamWeightType | undefined;
};

/**
 * Updated pipeline parameters for the stream
 */
export type Params = {
  /**
   * Base U-Net model to use for generation. Default: "stabilityai/sd-turbo"
   */
  modelId?: UpdateStreamModelId | undefined;
  /**
   * Text prompt describing the desired image. Can be a single string or weighted list of (prompt, weight) tuples.
   */
  prompt?: string | Array<Array<string | number>> | undefined;
  /**
   * Method for interpolating between multiple prompts. Slerp provides smoother transitions than linear.
   */
  promptInterpolationMethod?: UpdateStreamPromptInterpolationMethod | undefined;
  /**
   * Whether to normalize prompt weights to sum to 1.0 for consistent generation.
   */
  normalizePromptWeights?: boolean | undefined;
  /**
   * Whether to normalize seed weights to sum to 1.0 for consistent generation.
   */
  normalizeSeedWeights?: boolean | undefined;
  /**
   * Text describing what to avoid in the generated image.
   */
  negativePrompt?: string | undefined;
  /**
   * Strength of prompt adherence. Higher values make the model follow the prompt more strictly.
   */
  guidanceScale?: number | undefined;
  /**
   * Delta sets per-frame denoising progress: lower delta means steadier, less flicker but slower/softer; higher delta means faster, sharper but more flicker/artifacts (often reduce CFG).
   */
  delta?: number | undefined;
  /**
   * Builds the full denoising schedule (the 'grid' of possible refinement steps). Changing it changes what each step number (t_index_list value) means. Keep it fixed for a session and only adjust if you're deliberately redefining the schedule; if you do, proportionally remap your t_index_list. Typical range 10–200 with default being 50.
   */
  numInferenceSteps?: number | undefined;
  /**
   * The ordered list of step indices from the num_inference_steps schedule to execute per frame. Each index is one model pass, so latency scales with the list length. Higher indices (e.g., 40–49 on a 50-step grid) mainly polish and preserve structure (lower flicker), while lower indices (<20) rewrite structure (more flicker, creative). Values must be non-decreasing, and each between 0 and num_inference_steps.
   *
   * @remarks
   *
   * ⚠️ NOTE: t_index_list must have 1–4 elements, non-decreasing, and within [0, num_inference_steps].
   */
  tIndexList?: Array<number> | undefined;
  /**
   * Whether to use safety checker for content filtering
   */
  useSafetyChecker?: boolean | undefined;
  /**
   * Output image width in pixels. Must be divisible by 64 and between 384-1024.
   */
  width?: number | undefined;
  /**
   * Output image height in pixels. Must be divisible by 64 and between 384-1024.
   */
  height?: number | undefined;
  /**
   * Dictionary mapping LoRA model paths to their weights for fine-tuning the base model.
   */
  loraDict?: UpdateStreamLoraDict | null | undefined;
  /**
   * Whether to use Latent Consistency Model LoRA for faster inference.
   */
  useLcmLora?: boolean | undefined;
  /**
   * Identifier for the LCM LoRA model to use. Example: "latent-consistency/lcm-lora-sdv1-5"
   */
  lcmLoraId?: string | undefined;
  /**
   * Acceleration method for inference. Options: "none", "xformers", "tensorrt". TensorRT provides the best performance but requires engine compilation.
   */
  acceleration?: string | undefined;
  /**
   * Whether to process multiple denoising steps in a single batch for efficiency.
   */
  useDenoisingBatch?: boolean | undefined;
  /**
   * Whether to add noise to input frames before processing. Enabling this slightly re-noises each frame to improve temporal stability, reduce ghosting/texture sticking, and prevent drift; disabling can yield sharper, lower-latency results but may increase flicker and artifact accumulation over time.
   */
  doAddNoise?: boolean | undefined;
  /**
   * Random seed for generation. Can be a single integer or weighted list of (seed, weight) tuples.
   */
  seed?: number | Array<Array<number | number>> | undefined;
  /**
   * Method for interpolating between multiple seeds. Slerp provides smoother transitions than linear.
   */
  seedInterpolationMethod?: UpdateStreamSeedInterpolationMethod | undefined;
  /**
   * Whether to skip frames that are too similar to the previous output to reduce flicker.
   */
  enableSimilarImageFilter?: boolean | undefined;
  /**
   * Similarity threshold for the image filter. Higher values allow more variation between frames.
   */
  similarImageFilterThreshold?: number | undefined;
  /**
   * Maximum number of consecutive frames that can be skipped by the similarity filter.
   */
  similarImageFilterMaxSkipFrame?: number | undefined;
  /**
   * List of ControlNet configurations for guided generation. Each ControlNet provides different types of conditioning (pose, edges, depth, etc.). Dynamic updates limited to conditioning_scale changes only; cannot add new ControlNets or change model_id/preprocessor/params without reload.
   */
  controlnets?: Array<UpdateStreamControlnet> | undefined;
  /**
   * IP adapter — Turns on IP-Adapter style conditioning and is fully hot-swappable. Available for SDXL, SDXL-faceid, SD1.5
   */
  ipAdapter?: UpdateStreamIpAdapter | undefined;
  /**
   * HTTPS URL of the style image to use. When set, the runtime downloads the image and configures the pipeline; if omitted, a default style image is used. For 'faceid' type, the image must contain a clear face. Available for SDXL, SDXL-faceid, SD1.5
   */
  ipAdapterStyleImageUrl?: string | undefined;
};

export type UpdateStreamRequestBody = {
  /**
   * Updated pipeline parameters for the stream
   */
  params?: Params | undefined;
  /**
   * Updated prompt to apply to the stream processing
   */
  prompt?: string | undefined;
};

export type UpdateStreamRequest = {
  /**
   * ID of the stream to update
   */
  id: string;
  requestBody?: UpdateStreamRequestBody | undefined;
};

/**
 * Default Response
 */
export type UpdateStreamResponse = {
  /**
   * Unique identifier for the stream
   */
  id: string;
  /**
   * Unique key used for streaming to this endpoint
   */
  streamKey: string;
  /**
   * URL where the processed stream output can be accessed
   */
  outputStreamUrl: string;
  /**
   * Current configuration parameters for the stream pipeline
   */
  pipelineParams: { [k: string]: any };
  /**
   * ISO timestamp when the stream was created
   */
  createdAt: string;
  /**
   * ID of the processing pipeline being used
   */
  pipelineId: string;
  /**
   * Playback ID for accessing the stream output
   */
  outputPlaybackId: string;
  /**
   * Human-readable name of the stream
   */
  name: string;
  /**
   * ID of the user who created this stream
   */
  author: string;
  /**
   * Whether this stream was created from the playground interface
   */
  fromPlayground: boolean;
  /**
   * Gateway server hostname handling this stream
   */
  gatewayHost: string;
  /**
   * Whether this is a smoke test stream
   */
  isSmokeTest: boolean;
  /**
   * WebRTC WHIP URL for stream ingestion
   */
  whipUrl: string;
};

/** @internal */
export const UpdateStreamModelId$inboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamModelId
> = z.nativeEnum(UpdateStreamModelId);

/** @internal */
export const UpdateStreamModelId$outboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamModelId
> = UpdateStreamModelId$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamModelId$ {
  /** @deprecated use `UpdateStreamModelId$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamModelId$inboundSchema;
  /** @deprecated use `UpdateStreamModelId$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamModelId$outboundSchema;
}

/** @internal */
export const UpdateStreamPrompt2$inboundSchema: z.ZodType<
  UpdateStreamPrompt2,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number()]);

/** @internal */
export type UpdateStreamPrompt2$Outbound = string | number;

/** @internal */
export const UpdateStreamPrompt2$outboundSchema: z.ZodType<
  UpdateStreamPrompt2$Outbound,
  z.ZodTypeDef,
  UpdateStreamPrompt2
> = z.union([z.string(), z.number()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamPrompt2$ {
  /** @deprecated use `UpdateStreamPrompt2$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamPrompt2$inboundSchema;
  /** @deprecated use `UpdateStreamPrompt2$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamPrompt2$outboundSchema;
  /** @deprecated use `UpdateStreamPrompt2$Outbound` instead. */
  export type Outbound = UpdateStreamPrompt2$Outbound;
}

export function updateStreamPrompt2ToJSON(
  updateStreamPrompt2: UpdateStreamPrompt2,
): string {
  return JSON.stringify(
    UpdateStreamPrompt2$outboundSchema.parse(updateStreamPrompt2),
  );
}

export function updateStreamPrompt2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamPrompt2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamPrompt2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamPrompt2' from JSON`,
  );
}

/** @internal */
export const UpdateStreamPrompt1$inboundSchema: z.ZodType<
  UpdateStreamPrompt1,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.array(z.union([z.string(), z.number()])))]);

/** @internal */
export type UpdateStreamPrompt1$Outbound =
  | string
  | Array<Array<string | number>>;

/** @internal */
export const UpdateStreamPrompt1$outboundSchema: z.ZodType<
  UpdateStreamPrompt1$Outbound,
  z.ZodTypeDef,
  UpdateStreamPrompt1
> = z.union([z.string(), z.array(z.array(z.union([z.string(), z.number()])))]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamPrompt1$ {
  /** @deprecated use `UpdateStreamPrompt1$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamPrompt1$inboundSchema;
  /** @deprecated use `UpdateStreamPrompt1$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamPrompt1$outboundSchema;
  /** @deprecated use `UpdateStreamPrompt1$Outbound` instead. */
  export type Outbound = UpdateStreamPrompt1$Outbound;
}

export function updateStreamPrompt1ToJSON(
  updateStreamPrompt1: UpdateStreamPrompt1,
): string {
  return JSON.stringify(
    UpdateStreamPrompt1$outboundSchema.parse(updateStreamPrompt1),
  );
}

export function updateStreamPrompt1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamPrompt1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamPrompt1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamPrompt1' from JSON`,
  );
}

/** @internal */
export const UpdateStreamPromptInterpolationMethod$inboundSchema:
  z.ZodNativeEnum<typeof UpdateStreamPromptInterpolationMethod> = z.nativeEnum(
    UpdateStreamPromptInterpolationMethod,
  );

/** @internal */
export const UpdateStreamPromptInterpolationMethod$outboundSchema:
  z.ZodNativeEnum<typeof UpdateStreamPromptInterpolationMethod> =
    UpdateStreamPromptInterpolationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamPromptInterpolationMethod$ {
  /** @deprecated use `UpdateStreamPromptInterpolationMethod$inboundSchema` instead. */
  export const inboundSchema =
    UpdateStreamPromptInterpolationMethod$inboundSchema;
  /** @deprecated use `UpdateStreamPromptInterpolationMethod$outboundSchema` instead. */
  export const outboundSchema =
    UpdateStreamPromptInterpolationMethod$outboundSchema;
}

/** @internal */
export const UpdateStreamLoraDict$inboundSchema: z.ZodType<
  UpdateStreamLoraDict,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UpdateStreamLoraDict$Outbound = {};

/** @internal */
export const UpdateStreamLoraDict$outboundSchema: z.ZodType<
  UpdateStreamLoraDict$Outbound,
  z.ZodTypeDef,
  UpdateStreamLoraDict
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamLoraDict$ {
  /** @deprecated use `UpdateStreamLoraDict$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamLoraDict$inboundSchema;
  /** @deprecated use `UpdateStreamLoraDict$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamLoraDict$outboundSchema;
  /** @deprecated use `UpdateStreamLoraDict$Outbound` instead. */
  export type Outbound = UpdateStreamLoraDict$Outbound;
}

export function updateStreamLoraDictToJSON(
  updateStreamLoraDict: UpdateStreamLoraDict,
): string {
  return JSON.stringify(
    UpdateStreamLoraDict$outboundSchema.parse(updateStreamLoraDict),
  );
}

export function updateStreamLoraDictFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamLoraDict, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamLoraDict$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamLoraDict' from JSON`,
  );
}

/** @internal */
export const UpdateStreamSeed2$inboundSchema: z.ZodType<
  UpdateStreamSeed2,
  z.ZodTypeDef,
  unknown
> = z.union([z.number().int(), z.number()]);

/** @internal */
export type UpdateStreamSeed2$Outbound = number | number;

/** @internal */
export const UpdateStreamSeed2$outboundSchema: z.ZodType<
  UpdateStreamSeed2$Outbound,
  z.ZodTypeDef,
  UpdateStreamSeed2
> = z.union([z.number().int(), z.number()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamSeed2$ {
  /** @deprecated use `UpdateStreamSeed2$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamSeed2$inboundSchema;
  /** @deprecated use `UpdateStreamSeed2$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamSeed2$outboundSchema;
  /** @deprecated use `UpdateStreamSeed2$Outbound` instead. */
  export type Outbound = UpdateStreamSeed2$Outbound;
}

export function updateStreamSeed2ToJSON(
  updateStreamSeed2: UpdateStreamSeed2,
): string {
  return JSON.stringify(
    UpdateStreamSeed2$outboundSchema.parse(updateStreamSeed2),
  );
}

export function updateStreamSeed2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamSeed2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamSeed2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamSeed2' from JSON`,
  );
}

/** @internal */
export const UpdateStreamSeed1$inboundSchema: z.ZodType<
  UpdateStreamSeed1,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.number().int(),
  z.array(z.array(z.union([z.number().int(), z.number()]))),
]);

/** @internal */
export type UpdateStreamSeed1$Outbound = number | Array<Array<number | number>>;

/** @internal */
export const UpdateStreamSeed1$outboundSchema: z.ZodType<
  UpdateStreamSeed1$Outbound,
  z.ZodTypeDef,
  UpdateStreamSeed1
> = z.union([
  z.number().int(),
  z.array(z.array(z.union([z.number().int(), z.number()]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamSeed1$ {
  /** @deprecated use `UpdateStreamSeed1$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamSeed1$inboundSchema;
  /** @deprecated use `UpdateStreamSeed1$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamSeed1$outboundSchema;
  /** @deprecated use `UpdateStreamSeed1$Outbound` instead. */
  export type Outbound = UpdateStreamSeed1$Outbound;
}

export function updateStreamSeed1ToJSON(
  updateStreamSeed1: UpdateStreamSeed1,
): string {
  return JSON.stringify(
    UpdateStreamSeed1$outboundSchema.parse(updateStreamSeed1),
  );
}

export function updateStreamSeed1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamSeed1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamSeed1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamSeed1' from JSON`,
  );
}

/** @internal */
export const UpdateStreamSeedInterpolationMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamSeedInterpolationMethod
> = z.nativeEnum(UpdateStreamSeedInterpolationMethod);

/** @internal */
export const UpdateStreamSeedInterpolationMethod$outboundSchema:
  z.ZodNativeEnum<typeof UpdateStreamSeedInterpolationMethod> =
    UpdateStreamSeedInterpolationMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamSeedInterpolationMethod$ {
  /** @deprecated use `UpdateStreamSeedInterpolationMethod$inboundSchema` instead. */
  export const inboundSchema =
    UpdateStreamSeedInterpolationMethod$inboundSchema;
  /** @deprecated use `UpdateStreamSeedInterpolationMethod$outboundSchema` instead. */
  export const outboundSchema =
    UpdateStreamSeedInterpolationMethod$outboundSchema;
}

/** @internal */
export const UpdateStreamControlnetModelId$inboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamControlnetModelId
> = z.nativeEnum(UpdateStreamControlnetModelId);

/** @internal */
export const UpdateStreamControlnetModelId$outboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamControlnetModelId
> = UpdateStreamControlnetModelId$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamControlnetModelId$ {
  /** @deprecated use `UpdateStreamControlnetModelId$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamControlnetModelId$inboundSchema;
  /** @deprecated use `UpdateStreamControlnetModelId$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamControlnetModelId$outboundSchema;
}

/** @internal */
export const UpdateStreamControlnet$inboundSchema: z.ZodType<
  UpdateStreamControlnet,
  z.ZodTypeDef,
  unknown
> = z.object({
  model_id: UpdateStreamControlnetModelId$inboundSchema,
  conditioning_scale: z.number(),
  preprocessor: z.string(),
  preprocessor_params: z.record(z.any()).optional(),
  enabled: z.boolean(),
  control_guidance_start: z.number().optional(),
  control_guidance_end: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "model_id": "modelId",
    "conditioning_scale": "conditioningScale",
    "preprocessor_params": "preprocessorParams",
    "control_guidance_start": "controlGuidanceStart",
    "control_guidance_end": "controlGuidanceEnd",
  });
});

/** @internal */
export type UpdateStreamControlnet$Outbound = {
  model_id: string;
  conditioning_scale: number;
  preprocessor: string;
  preprocessor_params?: { [k: string]: any } | undefined;
  enabled: boolean;
  control_guidance_start?: number | undefined;
  control_guidance_end?: number | undefined;
};

/** @internal */
export const UpdateStreamControlnet$outboundSchema: z.ZodType<
  UpdateStreamControlnet$Outbound,
  z.ZodTypeDef,
  UpdateStreamControlnet
> = z.object({
  modelId: UpdateStreamControlnetModelId$outboundSchema,
  conditioningScale: z.number(),
  preprocessor: z.string(),
  preprocessorParams: z.record(z.any()).optional(),
  enabled: z.boolean(),
  controlGuidanceStart: z.number().optional(),
  controlGuidanceEnd: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    modelId: "model_id",
    conditioningScale: "conditioning_scale",
    preprocessorParams: "preprocessor_params",
    controlGuidanceStart: "control_guidance_start",
    controlGuidanceEnd: "control_guidance_end",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamControlnet$ {
  /** @deprecated use `UpdateStreamControlnet$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamControlnet$inboundSchema;
  /** @deprecated use `UpdateStreamControlnet$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamControlnet$outboundSchema;
  /** @deprecated use `UpdateStreamControlnet$Outbound` instead. */
  export type Outbound = UpdateStreamControlnet$Outbound;
}

export function updateStreamControlnetToJSON(
  updateStreamControlnet: UpdateStreamControlnet,
): string {
  return JSON.stringify(
    UpdateStreamControlnet$outboundSchema.parse(updateStreamControlnet),
  );
}

export function updateStreamControlnetFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamControlnet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamControlnet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamControlnet' from JSON`,
  );
}

/** @internal */
export const UpdateStreamType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamType
> = z.nativeEnum(UpdateStreamType);

/** @internal */
export const UpdateStreamType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamType
> = UpdateStreamType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamType$ {
  /** @deprecated use `UpdateStreamType$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamType$inboundSchema;
  /** @deprecated use `UpdateStreamType$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamType$outboundSchema;
}

/** @internal */
export const UpdateStreamWeightType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamWeightType
> = z.nativeEnum(UpdateStreamWeightType);

/** @internal */
export const UpdateStreamWeightType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateStreamWeightType
> = UpdateStreamWeightType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamWeightType$ {
  /** @deprecated use `UpdateStreamWeightType$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamWeightType$inboundSchema;
  /** @deprecated use `UpdateStreamWeightType$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamWeightType$outboundSchema;
}

/** @internal */
export const UpdateStreamIpAdapter$inboundSchema: z.ZodType<
  UpdateStreamIpAdapter,
  z.ZodTypeDef,
  unknown
> = z.object({
  scale: z.number(),
  enabled: z.boolean(),
  type: UpdateStreamType$inboundSchema.optional(),
  weight_type: UpdateStreamWeightType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "weight_type": "weightType",
  });
});

/** @internal */
export type UpdateStreamIpAdapter$Outbound = {
  scale: number;
  enabled: boolean;
  type?: string | undefined;
  weight_type?: string | undefined;
};

/** @internal */
export const UpdateStreamIpAdapter$outboundSchema: z.ZodType<
  UpdateStreamIpAdapter$Outbound,
  z.ZodTypeDef,
  UpdateStreamIpAdapter
> = z.object({
  scale: z.number(),
  enabled: z.boolean(),
  type: UpdateStreamType$outboundSchema.optional(),
  weightType: UpdateStreamWeightType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    weightType: "weight_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamIpAdapter$ {
  /** @deprecated use `UpdateStreamIpAdapter$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamIpAdapter$inboundSchema;
  /** @deprecated use `UpdateStreamIpAdapter$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamIpAdapter$outboundSchema;
  /** @deprecated use `UpdateStreamIpAdapter$Outbound` instead. */
  export type Outbound = UpdateStreamIpAdapter$Outbound;
}

export function updateStreamIpAdapterToJSON(
  updateStreamIpAdapter: UpdateStreamIpAdapter,
): string {
  return JSON.stringify(
    UpdateStreamIpAdapter$outboundSchema.parse(updateStreamIpAdapter),
  );
}

export function updateStreamIpAdapterFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamIpAdapter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamIpAdapter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamIpAdapter' from JSON`,
  );
}

/** @internal */
export const Params$inboundSchema: z.ZodType<Params, z.ZodTypeDef, unknown> = z
  .object({
    model_id: UpdateStreamModelId$inboundSchema.optional(),
    prompt: z.union([
      z.string(),
      z.array(z.array(z.union([z.string(), z.number()]))),
    ]).optional(),
    prompt_interpolation_method:
      UpdateStreamPromptInterpolationMethod$inboundSchema.optional(),
    normalize_prompt_weights: z.boolean().optional(),
    normalize_seed_weights: z.boolean().optional(),
    negative_prompt: z.string().optional(),
    guidance_scale: z.number().optional(),
    delta: z.number().optional(),
    num_inference_steps: z.number().int().optional(),
    t_index_list: z.array(z.number().int()).optional(),
    use_safety_checker: z.boolean().optional(),
    width: z.number().int().optional(),
    height: z.number().int().optional(),
    lora_dict: z.nullable(z.lazy(() => UpdateStreamLoraDict$inboundSchema))
      .optional(),
    use_lcm_lora: z.boolean().optional(),
    lcm_lora_id: z.string().optional(),
    acceleration: z.string().optional(),
    use_denoising_batch: z.boolean().optional(),
    do_add_noise: z.boolean().optional(),
    seed: z.union([
      z.number().int(),
      z.array(z.array(z.union([z.number().int(), z.number()]))),
    ]).optional(),
    seed_interpolation_method: UpdateStreamSeedInterpolationMethod$inboundSchema
      .optional(),
    enable_similar_image_filter: z.boolean().optional(),
    similar_image_filter_threshold: z.number().optional(),
    similar_image_filter_max_skip_frame: z.number().int().optional(),
    controlnets: z.array(z.lazy(() => UpdateStreamControlnet$inboundSchema))
      .optional(),
    ip_adapter: z.lazy(() => UpdateStreamIpAdapter$inboundSchema).optional(),
    ip_adapter_style_image_url: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "model_id": "modelId",
      "prompt_interpolation_method": "promptInterpolationMethod",
      "normalize_prompt_weights": "normalizePromptWeights",
      "normalize_seed_weights": "normalizeSeedWeights",
      "negative_prompt": "negativePrompt",
      "guidance_scale": "guidanceScale",
      "num_inference_steps": "numInferenceSteps",
      "t_index_list": "tIndexList",
      "use_safety_checker": "useSafetyChecker",
      "lora_dict": "loraDict",
      "use_lcm_lora": "useLcmLora",
      "lcm_lora_id": "lcmLoraId",
      "use_denoising_batch": "useDenoisingBatch",
      "do_add_noise": "doAddNoise",
      "seed_interpolation_method": "seedInterpolationMethod",
      "enable_similar_image_filter": "enableSimilarImageFilter",
      "similar_image_filter_threshold": "similarImageFilterThreshold",
      "similar_image_filter_max_skip_frame": "similarImageFilterMaxSkipFrame",
      "ip_adapter": "ipAdapter",
      "ip_adapter_style_image_url": "ipAdapterStyleImageUrl",
    });
  });

/** @internal */
export type Params$Outbound = {
  model_id?: string | undefined;
  prompt?: string | Array<Array<string | number>> | undefined;
  prompt_interpolation_method?: string | undefined;
  normalize_prompt_weights?: boolean | undefined;
  normalize_seed_weights?: boolean | undefined;
  negative_prompt?: string | undefined;
  guidance_scale?: number | undefined;
  delta?: number | undefined;
  num_inference_steps?: number | undefined;
  t_index_list?: Array<number> | undefined;
  use_safety_checker?: boolean | undefined;
  width?: number | undefined;
  height?: number | undefined;
  lora_dict?: UpdateStreamLoraDict$Outbound | null | undefined;
  use_lcm_lora?: boolean | undefined;
  lcm_lora_id?: string | undefined;
  acceleration?: string | undefined;
  use_denoising_batch?: boolean | undefined;
  do_add_noise?: boolean | undefined;
  seed?: number | Array<Array<number | number>> | undefined;
  seed_interpolation_method?: string | undefined;
  enable_similar_image_filter?: boolean | undefined;
  similar_image_filter_threshold?: number | undefined;
  similar_image_filter_max_skip_frame?: number | undefined;
  controlnets?: Array<UpdateStreamControlnet$Outbound> | undefined;
  ip_adapter?: UpdateStreamIpAdapter$Outbound | undefined;
  ip_adapter_style_image_url?: string | undefined;
};

/** @internal */
export const Params$outboundSchema: z.ZodType<
  Params$Outbound,
  z.ZodTypeDef,
  Params
> = z.object({
  modelId: UpdateStreamModelId$outboundSchema.optional(),
  prompt: z.union([
    z.string(),
    z.array(z.array(z.union([z.string(), z.number()]))),
  ]).optional(),
  promptInterpolationMethod:
    UpdateStreamPromptInterpolationMethod$outboundSchema.optional(),
  normalizePromptWeights: z.boolean().optional(),
  normalizeSeedWeights: z.boolean().optional(),
  negativePrompt: z.string().optional(),
  guidanceScale: z.number().optional(),
  delta: z.number().optional(),
  numInferenceSteps: z.number().int().optional(),
  tIndexList: z.array(z.number().int()).optional(),
  useSafetyChecker: z.boolean().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  loraDict: z.nullable(z.lazy(() => UpdateStreamLoraDict$outboundSchema))
    .optional(),
  useLcmLora: z.boolean().optional(),
  lcmLoraId: z.string().optional(),
  acceleration: z.string().optional(),
  useDenoisingBatch: z.boolean().optional(),
  doAddNoise: z.boolean().optional(),
  seed: z.union([
    z.number().int(),
    z.array(z.array(z.union([z.number().int(), z.number()]))),
  ]).optional(),
  seedInterpolationMethod: UpdateStreamSeedInterpolationMethod$outboundSchema
    .optional(),
  enableSimilarImageFilter: z.boolean().optional(),
  similarImageFilterThreshold: z.number().optional(),
  similarImageFilterMaxSkipFrame: z.number().int().optional(),
  controlnets: z.array(z.lazy(() => UpdateStreamControlnet$outboundSchema))
    .optional(),
  ipAdapter: z.lazy(() => UpdateStreamIpAdapter$outboundSchema).optional(),
  ipAdapterStyleImageUrl: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    modelId: "model_id",
    promptInterpolationMethod: "prompt_interpolation_method",
    normalizePromptWeights: "normalize_prompt_weights",
    normalizeSeedWeights: "normalize_seed_weights",
    negativePrompt: "negative_prompt",
    guidanceScale: "guidance_scale",
    numInferenceSteps: "num_inference_steps",
    tIndexList: "t_index_list",
    useSafetyChecker: "use_safety_checker",
    loraDict: "lora_dict",
    useLcmLora: "use_lcm_lora",
    lcmLoraId: "lcm_lora_id",
    useDenoisingBatch: "use_denoising_batch",
    doAddNoise: "do_add_noise",
    seedInterpolationMethod: "seed_interpolation_method",
    enableSimilarImageFilter: "enable_similar_image_filter",
    similarImageFilterThreshold: "similar_image_filter_threshold",
    similarImageFilterMaxSkipFrame: "similar_image_filter_max_skip_frame",
    ipAdapter: "ip_adapter",
    ipAdapterStyleImageUrl: "ip_adapter_style_image_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Params$ {
  /** @deprecated use `Params$inboundSchema` instead. */
  export const inboundSchema = Params$inboundSchema;
  /** @deprecated use `Params$outboundSchema` instead. */
  export const outboundSchema = Params$outboundSchema;
  /** @deprecated use `Params$Outbound` instead. */
  export type Outbound = Params$Outbound;
}

export function paramsToJSON(params: Params): string {
  return JSON.stringify(Params$outboundSchema.parse(params));
}

export function paramsFromJSON(
  jsonString: string,
): SafeParseResult<Params, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Params$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Params' from JSON`,
  );
}

/** @internal */
export const UpdateStreamRequestBody$inboundSchema: z.ZodType<
  UpdateStreamRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  params: z.lazy(() => Params$inboundSchema).optional(),
  prompt: z.string().optional(),
});

/** @internal */
export type UpdateStreamRequestBody$Outbound = {
  params?: Params$Outbound | undefined;
  prompt?: string | undefined;
};

/** @internal */
export const UpdateStreamRequestBody$outboundSchema: z.ZodType<
  UpdateStreamRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateStreamRequestBody
> = z.object({
  params: z.lazy(() => Params$outboundSchema).optional(),
  prompt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamRequestBody$ {
  /** @deprecated use `UpdateStreamRequestBody$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamRequestBody$inboundSchema;
  /** @deprecated use `UpdateStreamRequestBody$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamRequestBody$outboundSchema;
  /** @deprecated use `UpdateStreamRequestBody$Outbound` instead. */
  export type Outbound = UpdateStreamRequestBody$Outbound;
}

export function updateStreamRequestBodyToJSON(
  updateStreamRequestBody: UpdateStreamRequestBody,
): string {
  return JSON.stringify(
    UpdateStreamRequestBody$outboundSchema.parse(updateStreamRequestBody),
  );
}

export function updateStreamRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateStreamRequest$inboundSchema: z.ZodType<
  UpdateStreamRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  RequestBody: z.lazy(() => UpdateStreamRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UpdateStreamRequest$Outbound = {
  id: string;
  RequestBody?: UpdateStreamRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateStreamRequest$outboundSchema: z.ZodType<
  UpdateStreamRequest$Outbound,
  z.ZodTypeDef,
  UpdateStreamRequest
> = z.object({
  id: z.string(),
  requestBody: z.lazy(() => UpdateStreamRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamRequest$ {
  /** @deprecated use `UpdateStreamRequest$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamRequest$inboundSchema;
  /** @deprecated use `UpdateStreamRequest$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamRequest$outboundSchema;
  /** @deprecated use `UpdateStreamRequest$Outbound` instead. */
  export type Outbound = UpdateStreamRequest$Outbound;
}

export function updateStreamRequestToJSON(
  updateStreamRequest: UpdateStreamRequest,
): string {
  return JSON.stringify(
    UpdateStreamRequest$outboundSchema.parse(updateStreamRequest),
  );
}

export function updateStreamRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamRequest' from JSON`,
  );
}

/** @internal */
export const UpdateStreamResponse$inboundSchema: z.ZodType<
  UpdateStreamResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  stream_key: z.string(),
  output_stream_url: z.string(),
  pipeline_params: z.record(z.any()),
  created_at: z.string(),
  pipeline_id: z.string(),
  output_playback_id: z.string(),
  name: z.string(),
  author: z.string(),
  from_playground: z.boolean(),
  gateway_host: z.string(),
  is_smoke_test: z.boolean(),
  whip_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "stream_key": "streamKey",
    "output_stream_url": "outputStreamUrl",
    "pipeline_params": "pipelineParams",
    "created_at": "createdAt",
    "pipeline_id": "pipelineId",
    "output_playback_id": "outputPlaybackId",
    "from_playground": "fromPlayground",
    "gateway_host": "gatewayHost",
    "is_smoke_test": "isSmokeTest",
    "whip_url": "whipUrl",
  });
});

/** @internal */
export type UpdateStreamResponse$Outbound = {
  id: string;
  stream_key: string;
  output_stream_url: string;
  pipeline_params: { [k: string]: any };
  created_at: string;
  pipeline_id: string;
  output_playback_id: string;
  name: string;
  author: string;
  from_playground: boolean;
  gateway_host: string;
  is_smoke_test: boolean;
  whip_url: string;
};

/** @internal */
export const UpdateStreamResponse$outboundSchema: z.ZodType<
  UpdateStreamResponse$Outbound,
  z.ZodTypeDef,
  UpdateStreamResponse
> = z.object({
  id: z.string(),
  streamKey: z.string(),
  outputStreamUrl: z.string(),
  pipelineParams: z.record(z.any()),
  createdAt: z.string(),
  pipelineId: z.string(),
  outputPlaybackId: z.string(),
  name: z.string(),
  author: z.string(),
  fromPlayground: z.boolean(),
  gatewayHost: z.string(),
  isSmokeTest: z.boolean(),
  whipUrl: z.string(),
}).transform((v) => {
  return remap$(v, {
    streamKey: "stream_key",
    outputStreamUrl: "output_stream_url",
    pipelineParams: "pipeline_params",
    createdAt: "created_at",
    pipelineId: "pipeline_id",
    outputPlaybackId: "output_playback_id",
    fromPlayground: "from_playground",
    gatewayHost: "gateway_host",
    isSmokeTest: "is_smoke_test",
    whipUrl: "whip_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateStreamResponse$ {
  /** @deprecated use `UpdateStreamResponse$inboundSchema` instead. */
  export const inboundSchema = UpdateStreamResponse$inboundSchema;
  /** @deprecated use `UpdateStreamResponse$outboundSchema` instead. */
  export const outboundSchema = UpdateStreamResponse$outboundSchema;
  /** @deprecated use `UpdateStreamResponse$Outbound` instead. */
  export type Outbound = UpdateStreamResponse$Outbound;
}

export function updateStreamResponseToJSON(
  updateStreamResponse: UpdateStreamResponse,
): string {
  return JSON.stringify(
    UpdateStreamResponse$outboundSchema.parse(updateStreamResponse),
  );
}

export function updateStreamResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateStreamResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateStreamResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateStreamResponse' from JSON`,
  );
}
